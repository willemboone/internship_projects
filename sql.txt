CREATE TABLE dump_zones
(
	id serial PRIMARY KEY,
	category VARCHAR(255),
	Description VARCHAR(255),
	geometry GEOMETRY,
	name VARCHAR(50),
	price INT
);
-- import the data
COPY dump_zones
FROM 'D:\KUL\Master\stage\GeoSparc\webservices\Dump_zones_IODKortrijk_20190910.csv' null 'NULL' DELIMITER ',' CSV HEADER;

CREATE EXTENSION postgis;
Create table parking_bay(
	id serial PRIMARY KEY,
	connection_id INT,
	public_id INT, 
	netwerk_node_id INT,
	location GEOMETRY,
	parking_type_id INT,
	status_id INT,
	intake_url VARCHAR(255),
	locinfo_countyr VARCHAR(255),
	locinfo_zip_code INT,
	locinfo_city VARCHAR(50),
	locinfo_road VARCHAR(100),
	locinfo_house_nr INT,
	info_description VARCHAR(100),
	removal_date VARCHAR(100),
	geometry VARCHAR(100)
)
COPY parking_bay
FROM 'D:\KUL\Master\stage\GeoSparc\parktrack\parking_bay_20191030.csv' null 'NULL' DELIMITER ',' CSV HEADER;

Create table parking_types(
	parking_type_id INT,
	parking_type_name VARCHAR(255),
	parking_type_display_order INT,
	parking_bay_id SERIAL PRIMARY KEY,
	parking_bay_public_id INT
);

COPY parking_types
FROM 'D:\KUL\Master\stage\GeoSparc\parktrack\gspt_parking_types.csv' null 'NULL' DELIMITER ',' CSV HEADER;
Create table parking_zones(
	parking_zone_id INT,
	parking_zone_name VARCHAR(255),
	parking_bay_id INT,
	parking_bay_public_id INT
);

COPY parking_zones
FROM 'D:\KUL\Master\stage\GeoSparc\parktrack\gspt_parking_zones.csv' null 'NULL' DELIMITER ',' CSV HEADER;

select dz.geometry as geometrie, dz.category as categorie, dz.name as name, dz.description as beschrijving
from zone as dz
where category = 'gewestweg';

select dz.geometry as geomotrie, dz.category as categorie, dz.price as prijs, dz.name as naam, dz.description as beschrijving
from zone as dz
where dz.category = 'parking';

select 
i.location as locatie, it.name as type_vaststelling, i.description as beschrijving, i.status as status,
r.id as aanvraag_id,
i.created_by as opmaker, 
i.created_date as datum_opgemaakt, 
case
when (i.last_modified_by is null and isf.last_modified_by is null) then null
when (i.last_modified_by is not null and isf.last_modified_by is null) then i.last_modified_by
when (i.last_modified_by is null and isf.last_modified_by is not null) then isf.last_modified_by
when (i.last_modified_by is not null and isf.last_modified_by is not null) then isf.last_modified_by
end as recentste_bewerker,
case
when (i.last_modified_date is null and isf.last_modified_date is null) then null
when (i.last_modified_date is not null and isf.last_modified_date is null) then i.last_modified_date
when (i.last_modified_date is null and isf.last_modified_date is not null) then isf.last_modified_date
when (i.last_modified_date is not null and isf.last_modified_date is not null) then i.last_modified_date
end as laatst_bewerkt_op
from issue as i
join issue_type as it
on i.type_id = it.id
left join issue_file as isf
on i.id = isf.issue_id
left join request as r
on i.request_id = r.id;

select 
i.location as locatie, it.name as type_vaststelling, i.description as beschrijving, i.status as status,
r.id as aanvraag_id,
i.created_by as opmaker, 
i.created_date as datum_opgemaakt, 
case
when (i.last_modified_by is null and isf.last_modified_by is null) then null
when (i.last_modified_by is not null and isf.last_modified_by is null) then i.last_modified_by
when (i.last_modified_by is null and isf.last_modified_by is not null) then isf.last_modified_by
when (i.last_modified_by is not null and isf.last_modified_by is not null) then isf.last_modified_by
end as recentste_bewerker,
case
when (i.last_modified_date is null and isf.last_modified_date is null) then null
when (i.last_modified_date is not null and isf.last_modified_date is null) then i.last_modified_date
when (i.last_modified_date is null and isf.last_modified_date is not null) then isf.last_modified_date
when (i.last_modified_date is not null and isf.last_modified_date is not null) then i.last_modified_date
end as laatst_bewerkt_op
from issue as i
join issue_type as it
on i.type_id = it.id
left join issue_file as isf
on i.id = isf.issue_id
left join request as r
on i.request_id = r.id
left join request_period as rp
on r.id = rp.request_id
where 
i.status = 'OPEN';

select 
r.id as aanvraag_id,
r.location_geometry as geometrie,
rt.name as type_aanvraag,
concat(r.request_street, ' ', r.request_house_number) as straat_nr,
concat(r.request_zip_code, ' ', r.request_city) as postcode_gemeente,
rp.start_date as van, rp.end_date as tot,
r.location_description as detailomshrijving,
string_agg(DISTINCT rr.label, ',') as reden,
r.reason_description as aanvullende_omschrijving,
string_agg(DISTINCT rlp.license_plate, ',') as tijdelijke_parkeerkaarten,
string_agg(DISTINCT ghl.gipod_label, ',') as locatie_inname,
string_agg(DISTINCT ghg.gipod_label, ',') as gevolg_inname,
case
when r.valuemap ->> 'parkingSignsRequested' = 'false' then 'geen parkeerverbodsborden'
when r.valuemap ->> 'parkingSignsRequested' = 'true' then concat(r.valuemap ->> 'parkingSignsAmount', ' parkeerverbodsborden')
end
as parkeerverbodsborden
from request as r
right join request_period as rp
on r.id = rp.request_id
left join requesttype as rt
on r.type_id = rt.id
left join request_requestreason_extra as rre
on r.id = rre.request_id
left join request_reason as rr
on rre.request_reason_id = rr.id
left join request_gipod_hinder_gevolg as rghg 
on rghg.request_id = r.id
left join gipod_hinder_gevolg as ghg
on rghg.gipod_hinder_gevolg_id = ghg.id
left join gipod_hinder_locatie as ghl
on ghl.consequence_id = ghg.id
left join request_license_plate as rlp
on rlp.request_id = r.id
where 
now()::timestamp between rp.start_date and rp.end_date
group by r.id, r.location_geometry, rt.name, rp.start_date, rp.end_date, r.location_description
order by string_agg(DISTINCT rr.label, ','), string_agg(DISTINCT ghl.gipod_label, ','), string_agg(DISTINCT ghg.gipod_label, ',');

select 
r.id as aanvraag_id,
r.location_geometry as geometrie,
rt.name as type_aanvraag,
concat(r.request_street, ' ', r.request_house_number) as straat_nr,
concat(r.request_zip_code, ' ', r.request_city) as postcode_gemeente,
rp.start_date as van, rp.end_date as tot,
r.location_description as detailomshrijving,
string_agg(DISTINCT rr.label, ',') as reden,
r.reason_description as aanvullende_omschrijving,
string_agg(DISTINCT rlp.license_plate, ',') as tijdelijke_parkeerkaarten,
string_agg(DISTINCT ghl.gipod_label, ',') as locatie_inname,
string_agg(DISTINCT ghg.gipod_label, ',') as gevolg_inname,
case
when r.valuemap ->> 'parkingSignsRequested' = 'false' then 'geen parkeerverbodsborden'
when r.valuemap ->> 'parkingSignsRequested' = 'true' then concat(r.valuemap ->> 'parkingSignsAmount', ' parkeerverbodsborden')
end
as parkeerverbodsborden
from request as r
right join request_period as rp
on r.id = rp.request_id
left join requesttype as rt
on r.type_id = rt.id
left join request_requestreason_extra as rre
on r.id = rre.request_id
left join request_reason as rr
on rre.request_reason_id = rr.id
left join request_gipod_hinder_gevolg as rghg 
on rghg.request_id = r.id
left join gipod_hinder_gevolg as ghg
on rghg.gipod_hinder_gevolg_id = ghg.id
left join gipod_hinder_locatie as ghl
on ghl.consequence_id = ghg.id
left join request_license_plate as rlp
on rlp.request_id = r.id
group by r.id, r.location_geometry, rt.name, rp.start_date, rp.end_date, r.location_description;

select 
r.id as aanvraag_id,
r.location_geometry as geometrie,
rt.name as type_aanvraag,
concat(r.request_street, ' ', r.request_house_number) as straat_nr,
concat(r.request_zip_code, ' ', r.request_city) as postcode_gemeente,
rp.start_date as van, rp.end_date as tot,
r.location_description as detailomshrijving,
string_agg(DISTINCT rr.label, ',') as reden,
r.reason_description as aanvullende_omschrijving,
string_agg(DISTINCT rlp.license_plate, ',') as tijdelijke_parkeerkaarten,
string_agg(DISTINCT ghl.gipod_label, ',') as locatie_inname,
string_agg(DISTINCT ghg.gipod_label, ',') as gevolg_inname,
case
when r.valuemap ->> 'parkingSignsRequested' = 'false' then 'geen parkeerverbodsborden'
when r.valuemap ->> 'parkingSignsRequested' = 'true' then concat(r.valuemap ->> 'parkingSignsAmount', ' parkeerverbodsborden')
end
as parkeerverbodsborden
from request as r
right join request_period as rp
on r.id = rp.request_id
left join requesttype as rt
on r.type_id = rt.id
left join request_requestreason_extra as rre
on r.id = rre.request_id
left join request_reason as rr
on rre.request_reason_id = rr.id
left join request_gipod_hinder_gevolg as rghg 
on rghg.request_id = r.id
left join gipod_hinder_gevolg as ghg
on rghg.gipod_hinder_gevolg_id = ghg.id
left join gipod_hinder_locatie as ghl
on ghl.consequence_id = ghg.id
left join request_license_plate as rlp
on rlp.request_id = r.id
where rr.label like '%type%'
group by r.id, r.location_geometry, rt.name, rp.start_date, rp.end_date, r.location_description
order by string_agg(DISTINCT rr.label, ','), string_agg(DISTINCT ghl.gipod_label, ','), string_agg(DISTINCT ghg.gipod_label, ',');

select 
r.id as aanvraag_id,
rl.center as geometrie,
rt.name as type_aanvraag,
concat(r.request_street, ' ', r.request_house_number) as straat_nr,
concat(r.request_zip_code, ' ', r.request_city) as postcode_gemeente,
rp.start_date as van, rp.end_date as tot,
r.location_description as detailomshrijving,
string_agg(DISTINCT rr.label, ',') as reden,
r.reason_description as aanvullende_omschrijving,
string_agg(DISTINCT rlp.license_plate, ',') as tijdelijke_parkeerkaarten,
string_agg(DISTINCT ghl.gipod_label, ',') as locatie_inname,
string_agg(DISTINCT ghg.gipod_label, ',') as gevolg_inname,
case
when r.valuemap ->> 'parkingSignsRequested' = 'false' then 'geen parkeerverbodsborden'
when r.valuemap ->> 'parkingSignsRequested' = 'true' then concat(r.valuemap ->> 'parkingSignsAmount', ' parkeerverbodsborden')
end
as parkeerverbodsborden
from request as r
right join request_period as rp
on r.id = rp.request_id
left join requesttype as rt
on r.type_id = rt.id
left join request_requestreason_extra as rre
on r.id = rre.request_id
left join request_reason as rr
on rre.request_reason_id = rr.id
left join request_gipod_hinder_gevolg as rghg 
on rghg.request_id = r.id
left join gipod_hinder_gevolg as ghg
on rghg.gipod_hinder_gevolg_id = ghg.id
left join gipod_hinder_locatie as ghl
on ghl.consequence_id = ghg.id
left join request_license_plate as rlp
on rlp.request_id = r.id
left join request_location as rl
on r.id = rl.request_id
group by r.id, rl.center, rt.name, rp.start_date, rp.end_date, r.location_description
order by string_agg(DISTINCT rr.label, ','), string_agg(DISTINCT ghl.gipod_label, ','), string_agg(DISTINCT ghg.gipod_label, ',');

select 
rl.center as geometry,
rp.start_date as start_date,
rp.end_date as end_date,
rt.name as name, 
rr.label as label,
r.status as status
from request as r
right join request_location as rl
on r.id = rl.request_id
right join request_period as rp
on r.id = rp.request_id
left join requesttype as rt
on r.type_id = rt.id
left join request_reason as rr
on rr.id = r.reason_id;

select *
from 
	(select 
	pb.id as id, 
	pb.public_id as publiek_id,
	pb.location as locatie, 
	pt.parking_type_name as "type parkeerplaats",
	string_agg(DISTINCT pz.parking_zone_name, ', ') as zones,
	concat_ws(' ', pb.locinfo_city, pb.locinfo_road, pb.locinfo_house_nr) as "adres",
	pb.locinfo_zip_code as "postcode"

	from parking_bay as pb
	left join parking_zones as pz
	on pb.id = pz.parking_bay_id
	left join parking_types as pt
	on pb.id = pt.parking_bay_id

	group by pb.id, pt.parking_type_name
	)
as inner_q

where 
	case
		when('%ZONE%' = 'ZONE') then  inner_q.zones is null or inner_q.zones is not null
		when('%ZONE%' != 'ZONE') then inner_q.zones like '%%ZONE%%' 
	end
AND 
	case
		when('%TYPE%' = 'TYPE') then  inner_q.zones is null or inner_q.zones is not null
		when('%TYPE%' != 'TYPE') then inner_q.zones like '%%TYPE%%' 
	end;
